"""Audio Engine Service - Luxury perfume background music generation.

This service generates background music using Replicate's MusicGen model,
creating luxury ambient cinematic audio for perfume TikTok ads.

PHASE 7 IMPLEMENTATION:
- Simplified to single perfume-specific music generation method
- Gender-aware prompts (masculine, feminine, unisex)
- Luxury ambient cinematic style for all perfume ads

LOCAL-FIRST STORAGE:
- Music generated by Replicate
- Downloaded and saved to local storage
- Temporary file, deleted after final rendering
"""

import logging
from typing import Optional
from uuid import UUID
import replicate
import aiohttp
from pathlib import Path

logger = logging.getLogger(__name__)


# ============================================================================
# Audio Engine Service
# ============================================================================

class AudioEngine:
    """Generates background music using Replicate MusicGen."""

    def __init__(
        self,
        replicate_api_token: str,
        aws_access_key_id: str = None,
        aws_secret_access_key: str = None,
        s3_bucket_name: str = None,
        aws_region: str = "us-east-1",
    ):
        """Initialize with API credentials.
        
        Note: S3 credentials are optional now (local-first storage).
        Kept for backward compatibility.
        """
        self.api_token = replicate_api_token
        replicate.api_token = replicate_api_token
        
        # S3 credentials kept for backward compatibility but not used
        self.aws_region = aws_region

    async def generate_perfume_background_music(
        self,
        duration: float,
        campaign_id: str,
        gender: str = "unisex",  # 'masculine', 'feminine', 'unisex'
    ) -> str:
        """
        Generate background music for luxury perfume ad (simplified).

        Args:
            duration: Music duration in seconds
            campaign_id: Campaign UUID for local storage
            gender: Product gender ('masculine', 'feminine', 'unisex')

        Returns:
            Local file path to music file (in /tmp/genads/{campaign_id}/drafts/)
        """
        logger.info(f"ðŸŽµ Generating luxury perfume music ({duration}s, {gender})...")

        try:
            # Create perfume-specific prompt
            prompt = self._create_perfume_music_prompt(duration, gender)

            # Generate music via MusicGen
            music_url = await self._call_musicgen_model(prompt, duration)

            # Download and save to local storage
            local_path = await self._save_music_locally(music_url, campaign_id, "luxury_perfume")

            logger.info(f"âœ… Generated perfume music saved locally: {local_path}")
            return local_path

        except Exception as e:
            logger.error(f"âŒ Error generating perfume music: {e}")
            raise

    async def generate_background_music(
        self,
        mood: str,
        duration: float,
        campaign_id: str,
        tempo: str = "moderate",
    ) -> str:
        """
        Generate background music for video (LOCAL-FIRST).
        
        DEPRECATED: Use generate_perfume_background_music() for perfume ads.
        Kept for backward compatibility.

        Args:
            mood: Music mood/genre (e.g., "uplifting", "energetic", "calm", "modern")
            duration: Music duration in seconds
            campaign_id: Campaign UUID for local storage
            tempo: Tempo description ("slow", "moderate", "fast")

        Returns:
            Local file path to music file (in /tmp/genads/{campaign_id}/drafts/)
        """
        logger.info(f"ðŸŽµ Generating {mood} background music ({duration}s)...")

        try:
            # Create music prompt
            prompt = self._create_music_prompt(mood, duration, tempo)

            # Generate music via MusicGen
            music_url = await self._call_musicgen_model(prompt, duration)

            # Download and save to local storage
            local_path = await self._save_music_locally(music_url, campaign_id, mood)

            logger.info(f"âœ… Generated music saved locally: {local_path}")
            return local_path

        except Exception as e:
            logger.error(f"âŒ Error generating music: {e}")
            raise

    def _create_perfume_music_prompt(self, duration: float, gender: str) -> str:
        """Create music prompt for luxury perfume ad.
        
        Args:
            duration: Music duration in seconds
            gender: Product gender ('masculine', 'feminine', 'unisex')
            
        Returns:
            Formatted prompt string for MusicGen
        """
        gender_descriptors = {
            "masculine": "deep, confident, powerful, sophisticated",
            "feminine": "elegant, delicate, romantic, flowing",
            "unisex": "sophisticated, elegant, modern, refined"
        }
        
        gender_desc = gender_descriptors.get(gender.lower(), gender_descriptors["unisex"])
        
        prompt = (
            f"Luxury ambient cinematic background music for perfume commercial. "
            f"Mood: {gender_desc}. "
            f"Style: elegant, sophisticated, premium, ambient. "
            f"Tempo: slow to moderate. "
            f"Duration: {int(duration)} seconds. "
            f"Instrumental only, no vocals. "
            f"High-quality cinematic production suitable for luxury brand advertising."
        )
        
        logger.debug(f"Product music prompt: {prompt}")
        return prompt

    def _create_music_prompt(self, mood: str, duration: float, tempo: str) -> str:
        """Create music generation prompt.
        
        DEPRECATED: Use _create_perfume_music_prompt() for perfume ads.
        Kept for backward compatibility.
        """
        mood_descriptions = {
            "uplifting": "bright, positive, inspiring, motivational",
            "energetic": "dynamic, exciting, fast-paced, powerful",
            "calm": "peaceful, soothing, relaxing, gentle",
            "modern": "contemporary, sleek, trendy, sophisticated",
            "playful": "fun, lighthearted, whimsical, joyful",
            "dramatic": "intense, cinematic, epic, powerful",
            "corporate": "professional, confident, polished, business",
        }

        tempo_descriptions = {
            "slow": "slow tempo, around 60 BPM",
            "moderate": "moderate tempo, around 100 BPM",
            "fast": "fast tempo, around 140 BPM",
        }

        mood_text = mood_descriptions.get(mood.lower(), mood)
        tempo_text = tempo_descriptions.get(tempo.lower(), "moderate tempo")

        prompt = (
            f"Background music for product video advertisement. "
            f"Mood: {mood_text}. "
            f"{tempo_text}. "
            f"Duration: {int(duration)} seconds. "
            f"Instrumental music, no vocals. "
            f"Professional quality, suitable for commercial use."
        )

        logger.debug(f"Music prompt: {prompt}")
        return prompt

    async def _call_musicgen_model(self, prompt: str, duration: float) -> str:
        """Call Replicate MusicGen model (non-blocking, runs in thread pool).
        
        Includes retry logic for transient API errors (500, 502, 503, 504).
        """
        import asyncio
        from concurrent.futures import ThreadPoolExecutor
        import time
        
        # Retry configuration
        max_retries = 3
        retry_delays = [2, 5, 10]  # seconds between retries
        
        logger.info("Calling MusicGen model...")

        # MusicGen model parameters
        duration_sec = int(min(duration, 30))  # Cap at 30 seconds

        # Run synchronous replicate.run() in thread pool to avoid blocking event loop
        loop = asyncio.get_event_loop()
        executor = ThreadPoolExecutor(max_workers=1)
        
        def _run_replicate():
            """Synchronous wrapper for replicate.run()"""
            return replicate.run(
                "meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb",
                input={
                    "top_k": 250,
                    "top_p": 0,
                    "prompt": prompt,
                    "duration": duration_sec,
                    "temperature": 1,
                    "continuation": False,
                    "model_version": "stereo-large",
                    "output_format": "mp3",
                    "continuation_start": 0,
                    "multi_band_diffusion": False,
                    "normalization_strategy": "peak",
                    "classifier_free_guidance": 3,
                },
                wait=True,
            )
        
        # Retry logic for transient errors
        last_exception = None
        for attempt in range(max_retries):
            try:
                # Run in thread pool (non-blocking)
                output = await loop.run_in_executor(executor, _run_replicate)

                if isinstance(output, list) and len(output) > 0:
                    music_url = output[0]
                else:
                    music_url = output

                logger.info(f"ðŸŽµ MusicGen output: {music_url}")
                return str(music_url)
                
            except Exception as e:
                # Check if it's a ReplicateError (handle both old and new exception paths)
                is_replicate_error = (
                    hasattr(e, 'status') and 
                    hasattr(e, 'detail') and
                    type(e).__name__ == 'ReplicateError'
                )
                
                if is_replicate_error:
                    last_exception = e
                    # Check if it's a retryable error (5xx server errors)
                    error_status = getattr(e, 'status', None)
                    error_detail = getattr(e, 'detail', str(e))
                    
                    is_retryable = (
                        error_status and 
                        error_status >= 500 and 
                        error_status < 600
                    )
                    
                    if is_retryable and attempt < max_retries - 1:
                        delay = retry_delays[attempt]
                        logger.warning(
                            f"âŒ Replicate API error (attempt {attempt + 1}/{max_retries}): "
                            f"status={error_status}, detail={error_detail}. Retrying in {delay}s..."
                        )
                        await asyncio.sleep(delay)
                        continue
                    else:
                        # Non-retryable error or max retries reached
                        logger.error(
                            f"âŒ Replicate API error (attempt {attempt + 1}/{max_retries}): "
                            f"status={error_status}, detail={error_detail}"
                        )
                        raise
                else:
                    # Non-ReplicateError exceptions don't get retried
                    logger.error(f"âŒ Unexpected error calling MusicGen: {e}")
                    raise
        
        # Should never reach here, but just in case
        if last_exception:
            raise last_exception
        raise RuntimeError("Failed to generate music after retries")

    async def _save_music_locally(self, music_url: str, campaign_id: str, mood: str) -> str:
        """Download music from Replicate and save to local storage.
        
        Args:
            music_url: URL of music file from Replicate
            campaign_id: Campaign UUID
            mood: Music mood (for filename)
            
        Returns:
            Local file path (in /tmp/genads/{campaign_id}/drafts/music.mp3)
        """
        try:
            logger.info(f"â¬‡ï¸ Downloading music from Replicate...")
            
            # Download audio with extended timeout
            async with aiohttp.ClientSession() as session:
                async with session.get(music_url, timeout=aiohttp.ClientTimeout(total=300)) as resp:
                    if resp.status != 200:
                        raise ValueError(f"Failed to download music: HTTP {resp.status}")

                    audio_data = await resp.read()
                    logger.info(f"âœ… Downloaded {len(audio_data) / 1024 / 1024:.1f} MB from Replicate")

            # Save to local storage using LocalStorageManager
            from app.utils.local_storage import LocalStorageManager
            from uuid import UUID
            
            campaign_uuid = UUID(campaign_id)
            filename = "music.mp3"
            
            local_path = LocalStorageManager.save_draft_file(
                campaign_uuid,
                filename,
                audio_data
            )
            
            logger.info(f"âœ… Music saved locally: {local_path}")
            return local_path

        except Exception as e:
            logger.error(f"âŒ Error downloading/saving music: {e}")
            raise

    async def generate_music_variants(
        self,
        moods: list,
        duration: float,
        campaign_id: str,
    ) -> dict:
        """
        Generate multiple music variants.

        Args:
            moods: List of moods to generate
            duration: Duration for each
            campaign_id: Campaign ID

        Returns:
            Dict mapping mood to S3 URL
        """
        logger.info(f"Generating {len(moods)} music variants...")

        variants = {}

        for mood in moods:
            try:
                url = await self.generate_background_music(
                    mood=mood,
                    duration=duration,
                    campaign_id=campaign_id,
                )
                variants[mood] = url
            except Exception as e:
                logger.error(f"Failed to generate {mood} music: {e}")
                variants[mood] = None

        logger.info(f"âœ… Generated {len([v for v in variants.values() if v])} music variants")
        return variants

