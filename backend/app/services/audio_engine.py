"""Audio Engine Service - Background music generation.

This service generates background music using Replicate's MusicGen model,
creating mood-appropriate audio for product videos.

LOCAL-FIRST STORAGE:
- Music generated by Replicate
- Downloaded and saved to local storage
- Temporary file, deleted after final rendering
"""

import logging
from typing import Optional
from uuid import UUID
import replicate
import aiohttp
from pathlib import Path

logger = logging.getLogger(__name__)


# ============================================================================
# Audio Engine Service
# ============================================================================

class AudioEngine:
    """Generates background music using Replicate MusicGen."""

    def __init__(
        self,
        replicate_api_token: str,
        aws_access_key_id: str = None,
        aws_secret_access_key: str = None,
        s3_bucket_name: str = None,
        aws_region: str = "us-east-1",
    ):
        """Initialize with API credentials.
        
        Note: S3 credentials are optional now (local-first storage).
        Kept for backward compatibility.
        """
        self.api_token = replicate_api_token
        replicate.api_token = replicate_api_token
        
        # S3 credentials kept for backward compatibility but not used
        self.aws_region = aws_region

    async def generate_background_music(
        self,
        mood: str,
        duration: float,
        project_id: str,
        tempo: str = "moderate",
    ) -> str:
        """
        Generate background music for video (LOCAL-FIRST).

        Args:
            mood: Music mood/genre (e.g., "uplifting", "energetic", "calm", "modern")
            duration: Music duration in seconds
            project_id: Project UUID for local storage
            tempo: Tempo description ("slow", "moderate", "fast")

        Returns:
            Local file path to music file (in /tmp/genads/{project_id}/drafts/)
        """
        logger.info(f"ðŸŽµ Generating {mood} background music ({duration}s)...")

        try:
            # Create music prompt
            prompt = self._create_music_prompt(mood, duration, tempo)

            # Generate music via MusicGen
            music_url = await self._call_musicgen_model(prompt, duration)

            # Download and save to local storage
            local_path = await self._save_music_locally(music_url, project_id, mood)

            logger.info(f"âœ… Generated music saved locally: {local_path}")
            return local_path

        except Exception as e:
            logger.error(f"âŒ Error generating music: {e}")
            raise

    def _create_music_prompt(self, mood: str, duration: float, tempo: str) -> str:
        """Create music generation prompt."""
        mood_descriptions = {
            "uplifting": "bright, positive, inspiring, motivational",
            "energetic": "dynamic, exciting, fast-paced, powerful",
            "calm": "peaceful, soothing, relaxing, gentle",
            "modern": "contemporary, sleek, trendy, sophisticated",
            "playful": "fun, lighthearted, whimsical, joyful",
            "dramatic": "intense, cinematic, epic, powerful",
            "corporate": "professional, confident, polished, business",
        }

        tempo_descriptions = {
            "slow": "slow tempo, around 60 BPM",
            "moderate": "moderate tempo, around 100 BPM",
            "fast": "fast tempo, around 140 BPM",
        }

        mood_text = mood_descriptions.get(mood.lower(), mood)
        tempo_text = tempo_descriptions.get(tempo.lower(), "moderate tempo")

        prompt = (
            f"Background music for product video advertisement. "
            f"Mood: {mood_text}. "
            f"{tempo_text}. "
            f"Duration: {int(duration)} seconds. "
            f"Instrumental music, no vocals. "
            f"Professional quality, suitable for commercial use."
        )

        logger.debug(f"Music prompt: {prompt}")
        return prompt

    async def _call_musicgen_model(self, prompt: str, duration: float) -> str:
        """Call Replicate MusicGen model (non-blocking, runs in thread pool)."""
        try:
            import asyncio
            from concurrent.futures import ThreadPoolExecutor
            
            logger.info("Calling MusicGen model...")

            # MusicGen model parameters
            duration_sec = int(min(duration, 30))  # Cap at 30 seconds

            # Run synchronous replicate.run() in thread pool to avoid blocking event loop
            loop = asyncio.get_event_loop()
            executor = ThreadPoolExecutor(max_workers=1)
            
            def _run_replicate():
                """Synchronous wrapper for replicate.run()"""
                return replicate.run(
                    "meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb",
                    input={
                        "top_k": 250,
                        "top_p": 0,
                        "prompt": prompt,
                        "duration": duration_sec,
                        "temperature": 1,
                        "continuation": False,
                        "model_version": "stereo-large",
                        "output_format": "mp3",
                        "continuation_start": 0,
                        "multi_band_diffusion": False,
                        "normalization_strategy": "peak",
                        "classifier_free_guidance": 3,
                    },
                    wait=True,
                )
            
            # Run in thread pool (non-blocking)
            output = await loop.run_in_executor(executor, _run_replicate)

            if isinstance(output, list) and len(output) > 0:
                music_url = output[0]
            else:
                music_url = output

            logger.info(f"ðŸŽµ MusicGen output: {music_url}")
            return str(music_url)

        except Exception as e:
            logger.error(f"âŒ Replicate API error: {e}")
            raise

    async def _save_music_locally(self, music_url: str, project_id: str, mood: str) -> str:
        """Download music from Replicate and save to local storage.
        
        Args:
            music_url: URL of music file from Replicate
            project_id: Project UUID
            mood: Music mood (for filename)
            
        Returns:
            Local file path (in /tmp/genads/{project_id}/drafts/music.mp3)
        """
        try:
            logger.info(f"â¬‡ï¸ Downloading music from Replicate...")
            
            # Download audio with extended timeout
            async with aiohttp.ClientSession() as session:
                async with session.get(music_url, timeout=aiohttp.ClientTimeout(total=300)) as resp:
                    if resp.status != 200:
                        raise ValueError(f"Failed to download music: HTTP {resp.status}")

                    audio_data = await resp.read()
                    logger.info(f"âœ… Downloaded {len(audio_data) / 1024 / 1024:.1f} MB from Replicate")

            # Save to local storage using LocalStorageManager
            from app.utils.local_storage import LocalStorageManager
            from uuid import UUID
            
            project_uuid = UUID(project_id)
            filename = "music.mp3"
            
            local_path = LocalStorageManager.save_draft_file(
                project_uuid,
                filename,
                audio_data
            )
            
            logger.info(f"âœ… Music saved locally: {local_path}")
            return local_path

        except Exception as e:
            logger.error(f"âŒ Error downloading/saving music: {e}")
            raise

    async def generate_music_variants(
        self,
        moods: list,
        duration: float,
        project_id: str,
    ) -> dict:
        """
        Generate multiple music variants.

        Args:
            moods: List of moods to generate
            duration: Duration for each
            project_id: Project ID

        Returns:
            Dict mapping mood to S3 URL
        """
        logger.info(f"Generating {len(moods)} music variants...")

        variants = {}

        for mood in moods:
            try:
                url = await self.generate_background_music(
                    mood=mood,
                    duration=duration,
                    project_id=project_id,
                )
                variants[mood] = url
            except Exception as e:
                logger.error(f"Failed to generate {mood} music: {e}")
                variants[mood] = None

        logger.info(f"âœ… Generated {len([v for v in variants.values() if v])} music variants")
        return variants

